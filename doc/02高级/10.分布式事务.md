## 分布式事务

> 本文使用seata来简单实现基于分布式事务，二段提交协议，但是对于高并发的场景下是无法适用的，因此seata的情况不适用于我们目前的服务。







自动解锁库存：高并发的情况下的最终一致性方案

![image-20210721212023387](https://blog-images-code1997.oss-cn-hangzhou.aliyuncs.com/java/project/gmall/02high/image-20210721212023387.png)



场景：未付款的订单，超过一定的时间之后，系统自动取消订单并释放占有物品。

- 方案一：使用定时任务轮询数据库，会消耗系统内存，增加数据库的压力，存在比较大的时间误差。

- 方案二：Rabbit mq的TTL(Time To Live)+死信Exchange结合实现下订单和库存自动解锁。
  - 死信路由：存在死信的路由
    - 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false，也就是说不会再存放到队列中，被其他消费者使用。
    - 设置TTL，消息过期了。
    - 队列的长度限制满了，排在前面的消息被丢弃或者扔到死信路由上。
  - 下单的消息存放到一个队列中，设置过期时长为30分钟，一旦30分钟后没有被消费，就认为是被取消的订单，将其扔到其他的死信路由中去，只要代表进入到死信路由中的消息就代表，代表需要被解锁库存的订单。

简单图解：

![image-20210721214657652](https://blog-images-code1997.oss-cn-hangzhou.aliyuncs.com/java/project/gmall/02high/image-20210721214657652.png)

升级版本：

![image-20210721215056529](https://blog-images-code1997.oss-cn-hangzhou.aliyuncs.com/java/project/gmall/02high/image-20210721215056529.png)

简单实现





柔性事务-可靠消息+最终一致性：实现以服务中台来专门的发送消息

最终一致性的实现依赖于消息的传递，如何保证消息的可靠性？

1）消息丢失--最关键

- 消息发送出去，由于网络问题没有抵达服务器。
  - 做好容错方法try-catch，要有消息重试机制。
  - 做好日志记录，将发送的消息存到数据库中进行记录。
  - 做好定期重发，如果消息没有发送成功，定期去数据库中扫描未成功的消息进行重发。

- 消息抵达broker，broker一定做好持久化才算成功，此时broker尚未持久化成功，就宕机了。
  - 生产者加入确认回调机制，确认成功的发送消息，修改数据库消息表的消息状态。
- 自动ack的状态，消费者收到消息，但是还没来得及消费，然后宕机了。
  - 一定要开启手动ack，消费成功才可以移除，失败或者没来得及处理就noAck并重新入队。
- 总结：
  - 最好消息确认机制，publisher，consumer手动ack。
  - 做好每一个发送的消息在数据库中做好记录，定期进行扫描重发。

2）消息重复

- 消息消费成功，事务已经提交，ack的时候，机器宕机，导致没有ack成功，broker的消息重新由unack变为ready，并发送给其他消费者。
- 消息消费失败，由于重试机制，自动又将消息发送出去。
- 消息消费成功，事务已经提交，ack的时候，机器宕机，broker重新发送1。
  - 消费者的业务消费接口设计应该为幂等性，比如扣库存有工作单的状态标志。
  - 使用**防重表**，发送消息每一个都有业务的唯一表示，处理过就不再进行处理。
  - rabbitMq的每一个消息都有redelivered字段，用于区分是否是重新投递过来的。

3）消息积压

- 消费者宕机积压。
- 消费者消费能力不足积压。
- 发送者发送流量太大。
  - 上线更多的消费者，进行正常消费。
  - 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。

